"""
utils.py - Вспомогательные функции для ГОСТ 34.11-2018 (Стрибог)

Работа с байтами, арифметика по модулю 2^512, паддинг.
Все операции используют big-endian порядок байтов.
"""

from typing import Iterator


# ============================================================================
# КОНВЕРТАЦИЯ BYTES ↔ INT
# ============================================================================

def bytes_to_int(data: bytes) -> int:
    """
    Преобразует байтовый массив в целое число (big-endian).
    
    Args:
        data: Байтовый массив произвольной длины
        
    Returns:
        Целое неотрицательное число
        
    Example:
        >>> bytes_to_int(b'\\x01\\x02')
        258  # 0x0102
    """
    return int.from_bytes(data, byteorder='big')


def int_to_bytes(n: int, length: int) -> bytes:
    """
    Преобразует целое число в байтовый массив заданной длины (big-endian).
    
    Args:
        n: Неотрицательное целое число
        length: Требуемая длина в байтах
        
    Returns:
        Байтовый массив длины length
        
    Raises:
        OverflowError: Если число не помещается в length байт
        
    Example:
        >>> int_to_bytes(258, 2)
        b'\\x01\\x02'
    """
    return n.to_bytes(length, byteorder='big')


# ============================================================================
# АРИФМЕТИКА ПО МОДУЛЮ 2^512
# ============================================================================

def add_mod_2n_512(a: bytes, b: bytes) -> bytes:
    """
    Сложение двух 512-битных чисел по модулю 2^512.
    
    Используется для обновления счётчика N и контрольной суммы Σ.
    
    Args:
        a: Первое слагаемое (64 байта)
        b: Второе слагаемое (64 байта)
        
    Returns:
        Сумма (a + b) mod 2^512 (64 байта)
        
    Example:
        >>> a = b'\\xff' * 64
        >>> b = b'\\x01' + b'\\x00' * 63
        >>> result = add_mod_2n_512(a, b)
        >>> result == b'\\x00' * 64
        True
    """
    assert len(a) == 64, f"a должно быть 64 байта, получено {len(a)}"
    assert len(b) == 64, f"b должно быть 64 байта, получено {len(b)}"
    
    # Преобразуем в числа, складываем, берём остаток
    result = (bytes_to_int(a) + bytes_to_int(b)) % (2 ** 512)
    
    return int_to_bytes(result, 64)


# ============================================================================
# РАЗБИЕНИЕ НА БЛОКИ
# ============================================================================

def chunk_64(data: bytes) -> Iterator[bytes]:
    """
    Разбивает байтовый массив на блоки по 64 байта.
    
    Последний блок может быть короче 64 байт.
    
    Args:
        data: Входные данные произвольной длины
        
    Yields:
        Блоки по 64 байта (последний может быть короче)
        
    Example:
        >>> list(chunk_64(b'A' * 150))
        [b'A' * 64, b'A' * 64, b'A' * 22]
    """
    for i in range(0, len(data), 64):
        yield data[i:i+64]


# ============================================================================
# ПАДДИНГ
# ============================================================================

def pad_last_block(block: bytes) -> bytes:
    """
    Дополняет последний неполный блок до 512 бит по правилам ГОСТ.
    
    Правило: добавляется бит 1, затем нули до границы 512 бит.
    В байтовом представлении: байт 0x01, затем нулевые байты.
    
    Args:
        block: Последний блок сообщения (0-63 байта)
        
    Returns:
        Дополненный блок (64 байта)
        
    Raises:
        ValueError: Если блок >= 64 байт
        
    Example:
        >>> pad_last_block(b'ABC')
        b'ABC\\x01' + b'\\x00' * 60
    """
    if len(block) >= 64:
        raise ValueError(f"Блок должен быть < 64 байт, получено {len(block)}")
    
    # Добавляем байт 0x01, затем дополняем нулями до 64 байт
    padding_length = 64 - len(block) - 1
    return block + b'\x01' + (b'\x00' * padding_length)


# ============================================================================
# XOR ОПЕРАЦИЯ
# ============================================================================

def xor_bytes(a: bytes, b: bytes) -> bytes:
    """
    Покомпонентное XOR двух байтовых массивов одинаковой длины.
    
    Args:
        a: Первый операнд
        b: Второй операнд (той же длины, что и a)
        
    Returns:
        Результат a ⊕ b
        
    Raises:
        ValueError: Если длины не совпадают
        
    Example:
        >>> xor_bytes(b'\\xaa\\xaa', b'\\x55\\x55')
        b'\\xff\\xff'
    """
    if len(a) != len(b):
        raise ValueError(f"Длины должны совпадать: {len(a)} != {len(b)}")
    
    return bytes(x ^ y for x, y in zip(a, b))


# ============================================================================
# САМОТЕСТИРОВАНИЕ
# ============================================================================

def _self_check() -> None:
    """Проверка корректности работы утилит"""
    
    # Тест конвертации
    assert bytes_to_int(b'\x01\x02') == 258
    assert int_to_bytes(258, 2) == b'\x01\x02'
    
    # Тест сложения по модулю
    max_512 = b'\xff' * 64
    one = b'\x00' * 63 + b'\x01'
    zero = b'\x00' * 64
    assert add_mod_2n_512(max_512, one) == zero
    
    # Тест разбиения
    chunks = list(chunk_64(b'A' * 150))
    assert len(chunks) == 3
    assert len(chunks[0]) == 64
    assert len(chunks[1]) == 64
    assert len(chunks[2]) == 22
    
    # Тест паддинга
    padded = pad_last_block(b'ABC')
    assert len(padded) == 64
    assert padded[:3] == b'ABC'
    assert padded[3] == 0x01
    assert padded[4:] == b'\x00' * 60
    
    # Тест XOR
    assert xor_bytes(b'\xaa\xaa', b'\x55\x55') == b'\xff\xff'
    assert xor_bytes(b'\xff', b'\xff') == b'\x00'
    
    print("✓ Все утилиты работают корректно")


if __name__ == "__main__":
    _self_check()
