"""
compression.py - Функция сжатия ГОСТ 34.11-2018

Реализация:
- key_schedule: генерация раундовых ключей K₁...K₁₃
- E: функция шифрования (whitening + 12 LPS-раундов)
- g: функция сжатия g_N(h, m)
"""

from constants import C_CONSTANTS
from primitives import LPS, X
from utils import xor_bytes


# ============================================================================
# КЛЮЧЕВОЕ РАСПИСАНИЕ
# ============================================================================

def key_schedule(K0: bytes) -> list[bytes]:
    """
    Генерация раундовых ключей K₁...K₁₃.
    
    По стандарту:
    - K₁ = K₀
    - K_{i+1} = LPS(K_i ⊕ C_i) для i = 1...12
    
    Args:
        K0: Начальный ключ (64 байта)
        
    Returns:
        Список из 13 ключей [K₁, K₂, ..., K₁₃] (каждый 64 байта)
        
    Note:
        K₁ используется для whitening.
        K₂...K₁₃ используются в LPS-раундах.
    """
    assert len(K0) == 64, f"K0 должен быть 64 байта, получено {len(K0)}"
    
    keys = [K0]  # K₁ = K₀
    
    # Генерируем K₂...K₁₃
    for i in range(12):
        # K_{i+1} = LPS(K_i ⊕ C_i)
        K_prev = keys[-1]
        C_i = C_CONSTANTS[i]
        
        K_next = LPS(xor_bytes(K_prev, C_i))
        keys.append(K_next)
    
    assert len(keys) == 13, "Должно быть ровно 13 ключей"
    return keys


# ============================================================================
# ФУНКЦИЯ E (ШИФРОВАНИЕ)
# ============================================================================

def E(K0: bytes, m: bytes) -> bytes:
    """
    Функция шифрования E: V₅₁₂ × V₅₁₂ → V₅₁₂.
    
    Структура (справа налево):
    E(K₀, m) = X[K₁₃] ∘ LPS ∘ X[K₁₂] ∘ ... ∘ LPS ∘ X[K₂] ∘ LPS ∘ X[K₁](m)
    
    Итого:
    - 13 применений X (с ключами K₁...K₁₃)
    - 12 применений LPS (после K₁...K₁₂, но НЕ после K₁₃)
    """
    assert len(K0) == 64, f"E: K0 должен быть 64 байта, получено {len(K0)}"
    assert len(m) == 64, f"E: сообщение должно быть 64 байта, получено {len(m)}"
    
    # Генерируем раундовые ключи K₁...K₁₃
    keys = key_schedule(K0)
    
    state = m
    
    # Первые 12 раундов: X[K_i] → LPS
    for i in range(12):  # i = 0..11 → keys[0..11] = K₁..K₁₂
        state = X(keys[i], state)
        state = LPS(state)
    
    # Последний раунд: только X[K₁₃], БЕЗ LPS!
    state = X(keys[12], state)
    
    return state

# ============================================================================
# ФУНКЦИЯ СЖАТИЯ g
# ============================================================================

def g(N: bytes, h: bytes, m: bytes) -> bytes:
    """
    Функция сжатия g_N: V₅₁₂ × V₅₁₂ × V₅₁₂ → V₅₁₂.
    
    По стандарту (раздел 7):
    g_N(h, m) = E(LPS(h ⊕ N), m) ⊕ h ⊕ m
    
    Args:
        N: Счётчик обработанных бит (64 байта)
        h: Текущее состояние хэша (64 байта)
        m: Блок сообщения (64 байта)
        
    Returns:
        Новое состояние хэша (64 байта)
        
    Technical:
        1. Вычисляем ключ: K = LPS(h ⊕ N)
        2. Шифруем: E(K, m)
        3. Итоговый XOR: E(K, m) ⊕ h ⊕ m
    """
    assert len(N) == 64, f"g: N должен быть 64 байта, получено {len(N)}"
    assert len(h) == 64, f"g: h должен быть 64 байта, получено {len(h)}"
    assert len(m) == 64, f"g: m должен быть 64 байта, получено {len(m)}"
    
    # Шаг 1: K = LPS(h ⊕ N)
    K = LPS(xor_bytes(h, N))
    
    # Шаг 2: E(K, m)
    encrypted = E(K, m)
    
    # Шаг 3: E(K, m) ⊕ h ⊕ m
    result = xor_bytes(encrypted, h)
    result = xor_bytes(result, m)
    
    return result


# ============================================================================
# САМОТЕСТИРОВАНИЕ
# ============================================================================

def _self_check() -> None:
    """Проверка корректности функции сжатия"""
    
    # Тест ключевого расписания
    K0 = bytes(64)  # нулевой ключ
    keys = key_schedule(K0)
    assert len(keys) == 13, "Должно быть 13 ключей"
    assert all(len(k) == 64 for k in keys), "Все ключи должны быть 64 байта"
    assert keys[0] == K0, "K₁ должен равняться K₀"
    
    # Тест E: детерминированность
    m = bytes(64)
    e_result = E(K0, m)
    assert len(e_result) == 64
    assert E(K0, m) == e_result, "E должна быть детерминированной"
    
    # Тест g: структура
    N = bytes(64)
    h = bytes(64)
    g_result = g(N, h, m)
    assert len(g_result) == 64
    
    # Тест g: свойство (с нулевыми входами не равен нулю из-за констант)
    assert g_result != bytes(64), "g(0,0,0) не должен быть нулевым"
    
    print("✓ Функция сжатия работает корректно")


if __name__ == "__main__":
    _self_check()
